---
title: <font size="6">Recoding across multiple subsets of columns</font>
output: html_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

#### Overview

This a method for recoding all values within multiple subsets of columns. The need for this method arose in the TOD project in 2020. In those data sets, we had two types of missing data:

1. Missing item responses within subtests that were taken by examinees.
2. All item responses missing for certain subtests _not taken_ by examinees.

In these data sets, we first used BLIMP to impute all missing values, but then needed to go back and recode to missing certain subsets of items that were originally missing because the examinee did not attempt the subtests (type 2).

To accomplish this, we need both the original input data set, so we can identify cases that have type 2 missing data, and the BLIMP imputed output data set, because that is where the type 2 column subsets need to be recoded back to their original `NA` status.

###### RUNNABLE CODE
```{r script, eval = F}
library(tidyverse)

urlRemote_path  <- "https://raw.githubusercontent.com/"
github_path <- "DSHerzberg/GENERAL/master/INPUT-FILES/"

input_orig <- suppressMessages(read_csv(url(
  str_c(urlRemote_path, github_path, 
        "Recode-across-multiple-subsets-of-columns-dataOrig.csv")
)))

blimp_output <- suppressMessages(read_csv(url(
  str_c(urlRemote_path, github_path, 
        "BLIMP-impute-output.csv")
))) %>% 
  pivot_wider(names_from = item,
              values_from = response) %>%
  setNames(names(input_orig))

col_subsets <- c("i001:i050", "i051:i084", "i085:i114", "i115:i185", 
               "i186:i206", "i207:i251", "i252:i293")

miss_recode <- col_subsets %>%
  map_df(
    ~
      input_orig %>%
      filter(across(!!rlang::parse_expr(.x),
                    ~ is.na(.))) %>%
      mutate(recode_cols1 = .x) %>%
      select(ID, recode_cols1)
  ) %>%
  arrange(ID) %>%
  mutate(
    streak = runner::streak_run(ID),
    recode_cols2 = case_when(lead(streak) == 2 ~ lead(recode_cols1),
                             T ~ NA_character_),
    recode_cols3 = case_when(lead(streak, 2) == 3 ~ lead(recode_cols1, 2),
                             T ~ NA_character_)
  ) %>% 
  filter(streak == 1) %>% 
  select(-streak)

blimp_recode <- blimp_output %>%
  left_join(miss_recode, by = "ID") %>%
  relocate(c(recode_cols1, recode_cols2, recode_cols3), .after = "ID") %>%
  pivot_longer(cols = c(-ID, -recode_cols1, -recode_cols2, -recode_cols3),
               names_to = c("item")) %>%
  extract(
    recode_cols1,
    into = c("start1", "end1"),
    "([:alnum:]{4})?\\:?(.*)",
    remove = F
  ) %>%
  extract(
    recode_cols2,
    into = c("start2", "end2"),
    "([:alnum:]{4})?\\:?(.*)",
    remove = F
  ) %>%
  extract(
    recode_cols3,
    into = c("start3", "end3"),
    "([:alnum:]{4})?\\:?(.*)",
    remove = F
  ) %>%
  group_by(ID) %>%
  mutate(
    recode_run =
      case_when(
        start1 == item ~ "recode1",
        end1 == item ~ "recode1",
        start2 == item ~ "recode2",
        end2 == item ~ "recode2",
        start3 == item ~ "recode3",
        end3 == item ~ "recode3",
        T ~ NA_character_
      ),
    across(c(recode_run),
           ~ runner::fill_run(., only_within = T)),
    across(c(value),
           ~ case_when(
             recode_run %in% c("recode1", "recode2", "recode3") ~ NA_real_,
             T ~ value
           ))
  ) %>%
  select(ID, item, value) %>%
  pivot_wider(
    names_from = item,
    values_from = value) %>%
  ungroup()

# knitr::kable(head(blimp_recode))
```

<br>

###### COMMENTED SNIPPETS
First we read in the original input data set, which contains cases that are entirely missing on one, two, or three subsets of items. Note the use of `readr::read_csv(url())` to read in a file from a remote server (github).
```{r script, echo = 6:9, eval = F}
```
Now we read the output file that BLIMP generates when it imputes the missing data in `input_orig`. In this output, there are no missing data. 

Note that in this demonstration, `BLIMP-impute-output.csv` has column names. Usually, the raw output from a BLIMP imputation lacks column names. In this case, we must use the argument `col_names = F` in the call of `read_csv()`; otherwise R will erroneously read the first row of data as column names. We can then name the columns appropriately by inserting `base::setNames(c("ID", "item", "response"))` into the pipeline.

Additionally, the BLIMP output is in tall (multi-level) format, in which items and responses are nested within ID numbers. We can use `tidyr::pivot_wider()` to transform the data object into wide format, drawing the item column names from the `item` column, and the imputed responses from the `response` column. We then rename all columns to match the naming scheme of the original input data, using `setNames(names(input_orig))`.
```{r script, echo = 11:17, eval = F}
```
Now we initialize a character vector `col_subsets`, whose elements are strings holding the ranges of items for the seven item subsets that may need to be recoded for certain cases.
```{r script, echo = 19:20, eval = F}
```
The next code segment returns a data frame `miss_recode` whose rows are the cases that need item subsets recoded, identifying up to three subsets for each case. The basic structure is to use `map_df()` to apply functions to `input_orig`, iterating over the item ranges contained in `col_subsets`. Thus, wherever the token `.x` appears, `map_df()` substitutes the current element of `col_subsets` (e.g., `"i001:i050"`) into the code.

Central to this operation is `dplyr::filter()` which finds cases (rows) that meet logical criteria. To pass the column ranges into `filter()`, we use the helper `dplyr::across()`, which specifies a set of columns to be tested with the logical predicate. Within `across`, we need R to evaluate the column range `"i001:i050"` (for example) as an _expression_, not as a string. We can unquote the string using the `!!` operator, and then transform it into an expression with `rlang::parse_expr()`. We then specify the logical predicate `~ is.na(.)`, by which `filter()` will pick rows. `filter()` will thereby return only rows that are missing `NA` on _all_ columns within the range currently specified by `.x`, which is passed into `is.na()` with the single dot `.` shorthand.

We then use `dplyr::mutate()` to create a new variable `recode_cols1` that holds the label of the column range that is all missing for the filtered rows. `mutate()` can operate on `.x` with out any NSE transformations, because the value of `.x` is a string, which the variable type that we need to represent the column range in `recode_cols1`.  We use `dplyr::select()` to keep only the two columns we need.

At this point, if a case is all missing on more than one column range, it has a duplicate `ID` row for each of the ranges. We use `dplyr::arrange()` to sort the rows by `ID`, so the duplicate `ID` rows are adjacent to one another.
```{r script, echo = 22:31, eval = F}
```
We need now to execute a transformation by which the cases with multiple column ranges missing have the labels for those ranges placed in adjacent columns, as oppose to adjacent rows. To do this, we use `mutate()` to create three new columns. `streak` is the output of `runner::streak_run(ID)`, which, for each row, returns the count of consecutive instances of identical values of `ID`. Because the duplicate `ID` rows are adjacent, this function captures how many rows are duplicates, for each value of `ID` that has more than one row.

`recode_cols2` and `recode_cols3` are variables that hold the column ranges for those cases that have two or three ranges that are all missing. Our goal is to end up with a single row for each value of `ID`, with appropriate range labels in `recode_cols1`, `recode_cols2`, and `recode_cols3`, depending on how many column ranges are missing for each case. We want that single row to be the first in a set of identical `ID` rows, where the value of `streak` is 1.

For cases with more than one missing range, the labels for the second and third ranges are now located in adjacent rows. The second missing range has the value of 2 for `streak`, and the third missing range has the value of 3 for `streak`. To assign values to `recode_cols2` and `recode_cols3`, we use `dplyr::case_when()`, which assigns values to a variable based on logical conditions.

We identify the first row in a set of identical `ID` values with the predicate `lead(streak) == 2`, where `lead()` refers to the next row moving downward.  This captures only the first rows in sets of identical `ID` values, because any row that is not part of such a set would not be next to a row where `streak` is 2. For these first rows in sets of identical `ID` values, then, `case_when()` assigns a value to `recode_cols2` that it plucks from `recode_cols` in the next row, where `streak` is 2 (using the formula `~ lead(recode_cols1)`. This by definition is the label for the second all-missing range for that case. For any row that is _not_ the first row in a set of identical `ID` values, `case_when()` returns `NA`, via the argument `T ~ NA_character_`, which defines the "else" logical condition.

Values for `recode_cols3` are assigned with a similar procedure, except that we look ahead _two_ rows, by passing the argument `2` to `lead()`, where we find the label for any third set of all-missing columns where `streak` is 3.
```{r script, echo = 32:40, eval = F}
```
