---
title: <font size="6">Recoding across multiple subsets of columns</font>
output: html_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

#### Overview

This a method for recoding all values within multiple subsets of columns. The need for this method arose in the TOD project in 2020. In those data sets, we had two types of missing data:

1. Missing item responses within subtests that were taken by examinees.
2. All item responses missing for certain subtests _not taken_ by examinees.

In these data sets, we first used BLIMP to impute all missing values, but then needed to go back and recode to missing certain subsets of items that were originally missing because the examinee did not attempt the subtests (type 2).

To accomplish this, we need both the original input data set, so we can identify cases that have type 2 missing data, and the BLIMP imputed output data set, because that is where the type 2 column subsets need to be recoded back to their original `NA` status.

###### RUNNABLE CODE
```{r script, eval = F}
library(tidyverse)

urlRemote_path  <- "https://raw.githubusercontent.com/"
github_path <- "DSHerzberg/GENERAL/master/INPUT-FILES/"

input_orig <- suppressMessages(read_csv(url(
  str_c(urlRemote_path, github_path, 
        "Recode-across-multiple-subsets-of-columns-dataOrig.csv")
)))

blimp_output <- suppressMessages(read_csv(url(
  str_c(urlRemote_path, github_path, 
        "BLIMP-impute-output.csv")
))) %>% 
  pivot_wider(names_from = item,
              values_from = response) %>%
  setNames(names(input_orig))

col_subsets <- c("i001:i050", "i051:i084", "i085:i114", "i115:i185", 
               "i186:i206", "i207:i251", "i252:i293")

miss_recode <- col_subsets %>%
  map_df(
    ~
      input_orig %>%
      filter(across(!!rlang::parse_expr(.x),
                    ~ is.na(.))) %>%
      mutate(recode_cols1 = .x) %>%
      select(ID, recode_cols1)
  ) %>%
  arrange(ID) %>%
  mutate(
    streak = runner::streak_run(ID),
    recode_cols2 = case_when(lead(streak) == 2 ~ lead(recode_cols1),
                             T ~ NA_character_),
    recode_cols3 = case_when(lead(streak, 2) == 3 ~ lead(recode_cols1, 2),
                             T ~ NA_character_)
  ) %>% 
  filter(streak == 1) %>% 
  select(-streak)

blimp_recode <- blimp_output %>%
  left_join(miss_recode, by = "ID") %>%
  relocate(c(recode_cols1, recode_cols2, recode_cols3), .after = "ID") %>%
  pivot_longer(cols = c(-ID, -recode_cols1, -recode_cols2, -recode_cols3),
               names_to = c("item")) %>%
  extract(
    recode_cols1,
    into = c("start1", "end1"),
    "([:alnum:]{4})?\\:?(.*)",
    remove = F
  ) %>%
  extract(
    recode_cols2,
    into = c("start2", "end2"),
    "([:alnum:]{4})?\\:?(.*)",
    remove = F
  ) %>%
  extract(
    recode_cols3,
    into = c("start3", "end3"),
    "([:alnum:]{4})?\\:?(.*)",
    remove = F
  ) %>%
  group_by(ID) %>%
  mutate(
    recode_run =
      case_when(
        start1 == item ~ "recode1",
        end1 == item ~ "recode1",
        start2 == item ~ "recode2",
        end2 == item ~ "recode2",
        start3 == item ~ "recode3",
        end3 == item ~ "recode3",
        T ~ NA_character_
      ),
    across(c(recode_run),
           ~ runner::fill_run(., only_within = T)),
    across(c(value),
           ~ case_when(
             recode_run %in% c("recode1", "recode2", "recode3") ~ NA_real_,
             T ~ value
           ))
  ) %>%
  select(ID, item, value) %>%
  pivot_wider(
    names_from = item,
    values_from = value) %>%
  ungroup()

# knitr::kable(head(blimp_recode))
```

<br>

###### COMMENTED SNIPPETS
First we read in the original input data set, which contains cases that are entirely missing on one, two, or three subsets of items. Note the use of `readr::read_csv(url())` to read in a file from a remote server (github).
```{r script, echo = 6:9, eval = F}
```
Now we read the output file that BLIMP generates when it imputes the missing data in `input_orig`. In this output, there are no missing data. 

Note that in this demonstration, `BLIMP-impute-output.csv` has column names. Usually, the raw output from a BLIMP imputation lacks column names. In this case, we must use the argument `col_names = F` in the call of `read_csv()`; otherwise R will erroneously read the first row of data as column names. We can then name the columns appropriately by inserting `base::setNames(c("ID", "item", "response"))` into the pipeline.

Additionally, the BLIMP output is in tall (multi-level) format, in which items and responses are nested within ID numbers. We can use `tidyr::pivot_wider()` to transform the data object into wide format, drawing the item column names from the `item` column, and the imputed responses from the `response` column. We then rename all columns to match the naming scheme of the original input data, using `setNames(names(input_orig))`.
```{r script, echo = 11:17, eval = F}
```
Now we initialize a character vector `col_subsets`, whose elements are strings holding the ranges of items for the seven item subsets that may need to be recoded for certain cases.
```{r script, echo = 19:20, eval = F}
```
The next code segment returns a data frame `miss_recode` whose rows are the cases that need item subsets recoded, identifying up to three subsets for each case. The basic structure is to use `map_df()` to apply functions to `input_orig`, iterating over the item ranges contained in `col_subsets`. Thus, wherever the token `.x` appears, `map_df()` substitutes the current element of `col_subsets` into the code.

Central to this operation is `dplyr::filter()` which finds cases missing on all columns within a range. To pass the column ranges into `filter()`, we need R to evaluate `"i001:i050"` (for example) as an _expression_, not as a string.
```{r script, echo = 22:31, eval = F}
```
