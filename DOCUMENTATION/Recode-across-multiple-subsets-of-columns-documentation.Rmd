---
title: <font size="6">Recoding across multiple subsets of columns</font>
output: html_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

#### Overview

This a method for recoding all values within multiple subsets of columns. The need for this method arose in the TOD project in 2020. In those data sets, we had two types of missing data:

1. Missing item responses within subtests that were taken by examinees.
2. All item responses missing for certain subtests _not taken_ by examinees.

In these data sets, we first used BLIMP to impute all missing values, but then needed to go back and recode to missing certain subsets of items that were originally missing because the examinee did not attempt the subtests (type 2).

To accomplish this, we need both the original input data set, so we can identify cases that have type 2 missing data, and the BLIMP imputed output data set, because that is where the type 2 column subsets need to be recoded back to their original `NA` status.

<!-- TO PUBLISH, TOGGLE NEXT SNIPPET TO eval = T -->
###### RUNNABLE CODE
```{r script, eval = F}
library(tidyverse)

urlRemote_path  <- "https://raw.githubusercontent.com/"
github_path <- "DSHerzberg/GENERAL/master/INPUT-FILES/"

input_orig <- suppressMessages(read_csv(url(
  str_c(urlRemote_path, github_path, 
        "Recode-across-multiple-subsets-of-columns-dataOrig.csv")
)))

blimp_output <- suppressMessages(read_csv(url(
  str_c(urlRemote_path, github_path, 
        "BLIMP-impute-output.csv")
))) %>% 
  pivot_wider(names_from = item,
              values_from = response) %>%
  setNames(names(input_orig))

col_subsets <- c("i001:i050", "i051:i084", "i085:i114", "i115:i185", 
               "i186:i206", "i207:i251", "i252:i293")

miss_recode <- col_subsets %>%
  map_df(
    ~
      input_orig %>%
      filter(across(!!rlang::parse_expr(.x),
                    ~ is.na(.))) %>%
      mutate(recode_cols1 = .x) %>%
      select(ID, recode_cols1)
  ) %>%
  arrange(ID) %>%
  mutate(
    streak = runner::streak_run(ID),
    recode_cols2 = case_when(lead(streak) == 2 ~ lead(recode_cols1),
                             T ~ NA_character_),
    recode_cols3 = case_when(lead(streak, 2) == 3 ~ lead(recode_cols1, 2),
                             T ~ NA_character_)
  ) %>% 
  filter(streak == 1) %>% 
  select(-streak)

knitr::kable(slice(miss_recode, 7:9))

blimp_recode <- blimp_output %>%
  left_join(miss_recode, by = "ID") %>%
  relocate(c(recode_cols1, recode_cols2, recode_cols3), .after = "ID") %>%
  pivot_longer(cols = c(-ID, -recode_cols1, -recode_cols2, -recode_cols3),
               names_to = c("item")) %>%
  extract(
    recode_cols1,
    into = c("start1", "end1"),
    "([:alnum:]{4})?\\:?(.*)",
    remove = F
  ) %>%
  extract(
    recode_cols2,
    into = c("start2", "end2"),
    "([:alnum:]{4})?\\:?(.*)",
    remove = F
  ) %>%
  extract(
    recode_cols3,
    into = c("start3", "end3"),
    "([:alnum:]{4})?\\:?(.*)",
    remove = F
  ) %>%
  group_by(ID) %>%
  mutate(
    recode_run =
      case_when(
        start1 == item ~ "recode1",
        end1 == item ~ "recode1",
        start2 == item ~ "recode2",
        end2 == item ~ "recode2",
        start3 == item ~ "recode3",
        end3 == item ~ "recode3",
        T ~ NA_character_
      ),
    across(c(recode_run),
           ~ runner::fill_run(., only_within = T)),
    across(c(value),
           ~ case_when(
             recode_run %in% c("recode1", "recode2", "recode3") ~ NA_real_,
             T ~ value
           ))
  ) %>%
  select(ID, item, value) %>%
  pivot_wider(
    names_from = item,
    values_from = value) %>%
  ungroup()

# knitr::kable(head(blimp_recode))
```

<br>

###### COMMENTED SNIPPETS
First we read in the original input data set, which contains cases that are entirely missing on one, two, or three subsets of items. Note the use of `readr::read_csv(url())` to read in a file from a remote server (github).
```{r script, echo = 6:9, eval = F}
```
Now we read the output file that BLIMP generates when it imputes the missing data in `input_orig`. In this output, there are no missing data. 

Note that in this demonstration, `BLIMP-impute-output.csv` has column names. Usually, the raw output from a BLIMP imputation lacks column names. In this case, we must use the argument `col_names = F` in the call of `read_csv()`; otherwise R will erroneously read the first row of data as column names. We can then name the columns appropriately by inserting `base::setNames(c("ID", "item", "response"))` into the pipeline.

Additionally, the BLIMP output is in tall (multi-level) format, in which items and responses are nested within ID numbers. We can use `tidyr::pivot_wider()` to transform the data object into wide format, drawing the item column names from the `item` column, and the imputed responses from the `response` column. We then rename all columns to match the naming scheme of the original input data, using `setNames(names(input_orig))`.
```{r script, echo = 11:17, eval = F}
```
Now we initialize a character vector `col_subsets`, whose elements are strings holding the ranges of items for the seven item subsets that may need to be recoded for certain cases.
```{r script, echo = 19:20, eval = F}
```
The next code segment returns a data frame `miss_recode` whose rows are the cases that need column subsets recoded, with up to three subsets identified per case. We use `map_df()` to apply functions to `input_orig`, iterating over the column ranges contained in `col_subsets`. Thus, wherever the token `.x` appears, `map_df()` substitutes the current-iteration element of `col_subsets` (e.g., `"i001:i050"`) into the code.

Central to this operation is `dplyr::filter()` which finds cases (rows) that meet logical criteria. To pass the column ranges into `filter()`, we use the helper `dplyr::across()`, which specifies a set of columns to be tested against a logical predicate. Within `across`, we need R to evaluate the column range `"i001:i050"` (for example) as an _expression_, not as a string. We can unquote the string using the `!!` operator, and then transform it into an expression with `rlang::parse_expr()`. We then specify the logical predicate `~ is.na(.)`, by which `filter()` will pick rows. `filter()` thereby returns only rows that are missing `NA` on _all_ columns within the range currently specified by `.x`, which is passed into `is.na()` with the single dot `.` shorthand.

We then use `dplyr::mutate()` to create a new variable `recode_cols1` that holds the label of the first column range that is all missing for the filtered rows. Here, `mutate()` can operate on `.x` with out any NSE transformations, because the value of `.x` is a string, which is the correct variable type to represent the column range in `recode_cols1`.  We use `dplyr::select()` to keep only two columns going forward.

In the current data object, if a case is all missing on more than one column range, it has a duplicate `ID` row for each of the ranges. We use `dplyr::arrange()` to sort the rows by `ID`, so the duplicate `ID` rows are adjacent to one another.
```{r script, echo = 22:31, eval = F}
```
We now execute a transformation by which cases with multiple missing column ranges missing have the labels for those ranges placed in new columns, as oppose to adjacent rows within the `recode_cols1` column. To do this, we use `mutate()` to create three new columns. `streak` is the output of `runner::streak_run(ID)`, which returns each row's ordinal position within a sequence of consecutive instances of identical values of `ID`. In other words, `streak` is always 1 for non-duplicate values of `ID`. For duplicate `ID` rows, `streak` is 2 or 3, respectively, for the second or third consecutive occurrence of the same `ID` value.

`recode_cols2` and `recode_cols3` are variables that hold labels for the second and third all-missing column ranges, for any cases that have them. We need a single row for each value of `ID`, with appropriate range labels in `recode_cols1`, `recode_cols2`, and `recode_cols3`, depending on how many column ranges are missing for each case. That single row will be the first in a set of identical `ID` rows, where the value of `streak` is 1.

For cases with more than one all-missing range, the labels for the second and third ranges are now located in adjacent rows within the `recode_cols1` column. In the rows containing the second and third missing ranges, `streak` is 2 or 3, respectively. To copy the labels for these second and third missing ranges into `recode_cols2` and `recode_cols3`, we use `dplyr::case_when()`, which assigns values to a variable based on logical conditions.

We identify the first row in a set of duplicate `ID` rows with the predicate `lead(streak) == 2`, where `lead()` refers to the next row moving downward.  This captures only the first rows in sets of identical `ID` values, because by definition, only these rows are adjacent to rows where `streak` is 2. For these first rows in sets of identical `ID` values, then, `case_when()` assigns a value to `recode_cols2` that it plucks from `recode_cols1` in the next row, where `streak` is 2 (using the formula `~ lead(recode_cols1)`. This value is the label for the second all-missing range for that case. For any row that is _not_ the first row in a set of identical `ID` values, `case_when()` returns `NA`, via the argument `T ~ NA_character_`, which defines the "else" logical condition.

We assign values for `recode_cols3` with a similar procedure, except here we look ahead _two_ rows, by passing the argument `2` to `lead()`. Two rows ahead is where we will find the label for any third set of all-missing columns (and where the value of `streak` is 3).

To finish the procedure, we drop the superfluous duplicate `ID` rows by calling `filter(streak == 1)`. We no longer need rows where `streak` is 2 or 3, because those rows contain column range labels are now registered in `recode_cols2` and `recode_cols3`. The resulting data object `miss_recode` contains a single row for each case that requires recoding of column ranges.
```{r script, echo = 32:40, eval = F}
```
<!-- TO PUBLISH, TOGGLE NEXT SNIPPET TO eval = T -->
```{r script, echo = 42, eval = F}
```
The next segment operates on the BLIMP imputed data file, and recodes cases that, in the original input file, were all missing on one or more column subsets. To begin, we use `dplyr::left_join()` to bind the `blimp_output` and `miss_recode` data frames, passing `by = "ID"` to align the columns by `ID`. We `relocate()` columns to obtain a desired sequence. 

We then `pivot_longer()` to transform the data object into the tall (multilevel format), in which items and responses are nested within each value of `ID`. In the argument `cols = c(-ID, -recode_cols1, -recode_cols2, -recode_cols3)` we exclude the four named columns from the pivot to the longer format, thus establishing that in the outer level of nesting, each value of `ID` will be paired with the correct labels contained in the three `recode_cols` columns. In the resulting long data object, the input column names are contained in a single column given by the argument `names_to = c("item")`, and the paired responses are contained the `value` column. As a result, we now need only recode values in a single column. In the wide format, we would have needed to recode multiple columns, which would require more elaborate code.
```{r script, echo = 44:48, eval = F}
```
We now use `tidyr::extract()` to create new columns that will hold markers delineating the ranges of rows in the `value` column that need to be recoded. Here we examine only the code segment that operates on `recode_cols1`; an analogous procedure is used on `recode_cols2` and `recode_cols3`.

`extract()` splits strings contained in one column and places each part into a new column. The first argument names `recode_cols1` as the source column, and the second argument (`into =`) names `start1` and `end1` as the two destination columns. The third argument `"([:alnum:]{4})?\\:?(.*)"` is a regular expression that specifies how and where to split the value contained in `recode_cols1` into two strings. For example, we can split the range label `"i001:i050"` into `i001` (the first item number in the range) and `i050` (the last item number in the range). Within the regular expression the `?` characters separate the string segment going to `start1` (`([:alnum:]{4})`), the string segment dropped in the transformation (`\\:`), and the string segment going to `end1` (`(.*)`). The final argument `remove = F` indicates that the source column will be retained in the output.
```{r script, echo = 49:54, eval = F}
```
